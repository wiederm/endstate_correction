Getting Started
===============

This page details how to get started with endstate_correction. 

Installation
-----------------

We recommend setting up a new python conda environment with :code:`python=3.9` and installing the packages defined here using :code:`mamba`: https://github.com/wiederm/endstate_correction/blob/main/devtools/conda-envs/test_env.yaml.
This package can be installed using:
:code:`pip install git+https://github.com/wiederm/endstate_correction.git`.


How to use this package
-----------------

We have prepared two scripts that should help to use this package, both are located in :code:`endstate_correction/scripts`.
We will start by describing the use of the  :code:`sampling.py` script and then discuss the :code:`perform_correction.py` script.

A typical NEQ workflow
----------------------------------

### Generate the equilibrium distribution :math:`\pi(x, \lambda=0)`


In order to perform a NEQ work protocol, we need samples drawn from the equilibrium distribution from which we initialize our trial moves.
If samples are not already available, the `sampling.py` script provides and easy way to obtain these samples.

We start by setting up an openMM system object. Here, we use CHARMM parameter and files, but any other supported parameter set and files can be used. We start by defining a ``CharmmPsfFile``, ``PDBFile`` and ``CharmmParameterSet``:  

.. code::
    psf = CharmmPsfFile(f"{parameter_base}/{system_name}/charmm-gui/openmm/step3_input.psf")
    pdb = PDBFile(f"{parameter_base}/{system_name}/charmm-gui/openmm/step3_input.pdb")
    params = CharmmParameterSet(
        f"{parameter_base}/{system_name}/charmm-gui/unk/unk.rtf",
        f"{parameter_base}/{system_name}/charmm-gui/unk/unk.prm",
        f"{parameter_base}/toppar/top_all36_cgenff.rtf",
        f"{parameter_base}/toppar/par_all36_cgenff.prm",
        f"{parameter_base}/toppar/toppar_water_ions.str",
    )

and then we define the atoms that should be perturbed using the coupling parameter :math:`\lambda` with

.. code:: python
ml_atoms = [atom.index for atom in chains[0].atoms()]

Depending if all atoms in your system are included in the :code:`ml_atoms` list or only a subset, you can set up your QML or QML/MM simulation object using 

.. code:: python
sim = create_charmm_system(psf=psf, parameters=params, env=env, ml_atoms=ml_atoms)


That is everything you need to define to run the equilibrium sampling. 
The parameters defining the number of samples to save and time interval between samples can be defined in the script.
Keep in mind that if you want to perform bidirectional FEP you need to sample at :math:`\pi(x, \lambda=0)` and :math:`\pi(x, \lambda=1)`. 
This can be controlled by setting the number using the variable `nr_lambda_states`.

Perform unidirectional NEQ from :math:`\pi(x, \lambda=0)`
----------------------------------
The endstate correction can be performed using the script :code:`perform_correction.py`.
Again, we need to initialize the simulation object as described above.
To perform a specific endstate correction we need to define a protocol (some standard protocols are shown here https://github.com/wiederm/endstate_correction/blob/main/endstate_correction/tests/test_endstate_correction.py) with:

.. code:: python
  fep_protocoll = Protocoll(
      method="NEQ",
      direction="unidirectional",
      sim=sim,
      trajectories=[mm_samples],
      nr_of_switches=400,
      neq_switching_length=5_000, # in fs
  )

.
This protocol is then passed to the actual function performing the protocol: :code:`perform_endstate_correction(fep_protocoll)`.

Analyse results of an unidirection NEQ protocol
----------------------------------

To analyse the results generated by :code:`r = perform_endstate_correction()` pass the return value to :code:`plot_endstate_correction_results(system_name, r, "results_neq_unidirectional.png")` and results will be plotted and printed.
